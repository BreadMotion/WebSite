<!doctype html>
<html lang="ja">
  <head prefix="og: https://ogp.me/ns#">
    <meta charset="UTF-8" />
    <title>Odin でコンテキストエディター作ってみた | PanKUN Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Odin でプランナー向けのコンテキストエディターを作った話" />

    <meta property="og:title" content="Odin でコンテキストエディター作ってみた | PanKUN Blog" />
    <meta property="og:description" content="Odin でプランナー向けのコンテキストエディターを作った話" />
    <meta property="og:type" content="blog" />
    <meta property="og:image" content="../assets/img/ogp.png" />
    <meta property="og:site_name" content="PanKUN" />
    <meta property="og:email" content="pankun.dev@gmail.com" />

    <link rel="stylesheet" href="../assets/css/base.css" />
    <link rel="stylesheet" href="../assets/css/layout.css" />
    <link rel="stylesheet" href="../assets/css/blog.css" />
  </head>
  <body data-page="blog">
    <div class="page-shell">
      <main class="main-container">
        <article class="post-detail reveal-on-scroll">
          <header class="post-detail__header">
            <p class="post-detail__meta">Mon Jun 10 2024 09:00:00 GMT+0900 (GMT+09:00) / Unity</p>
            <h1 class="post-detail__title">Odin でコンテキストエディター作ってみた</h1>
            <p class="post-detail__description">Odin でプランナー向けのコンテキストエディターを作った話</p>
            <p class="post-detail__tags"><a class="tag" href="../blog.html?tag=unity">unity</a> <a class="tag" href="../blog.html?tag=plugin">plugin</a> <a class="tag" href="../blog.html?tag=tool">tool</a></p>
          </header>

          <section class="post-detail__body markdown-body">
<p>こんにちは！パン君です。</p>
<p>インディーズのプロジェクトで <strong>Odin Inspector</strong> を使用して、<br>プランナーが Unity の知見をあまり持っていなくても触れるような、**プロジェクト専用の「コンテキストエディター」**を作成しました。</p>
<p>ここでいう「コンテキストエディター」は、</p>
<blockquote>
<p>「ゲーム内の◯◯に関係するデータを、ひとつの画面でまとめて編集できるツール」</p>
</blockquote>
<p>のイメージです。</p>
<ul>
<li>キャラやステージのパラメータ</li>
<li>掲載テキストや説明文</li>
<li>報酬テーブルやフラグ設定</li>
</ul>
<p>など、<strong>まとまりとして扱いたい情報を、一箇所から編集できるようにした</strong>という話になります。</p>
<hr>
<h2>概要</h2>
<p>もともとプロジェクトでは、データ構造を ScriptableObject や CSV で管理していましたが、</p>
<ul>
<li>「どのデータがどこにあるのか」が分かりづらい</li>
<li>パラメータを変えるために <strong>何個もアセットを開く必要がある</strong></li>
<li>プランナーが Unity の Project ウィンドウを漁るのに時間がかかる</li>
</ul>
<p>という課題がありました。</p>
<p>そこで、</p>
<blockquote>
<p>「◯◯の仕様を触るときは、とりあえずこのウィンドウを開けばいい」</p>
</blockquote>
<p>という <strong>専用の編集画面（コンテキストエディター）</strong> を Odin で作りました。</p>
<p>やったことをざっくりまとめると：</p>
<ul>
<li>Odin の <code>OdinEditorWindow</code> を使って <strong>専用ウィンドウを作成</strong></li>
<li>プランナーが触る想定の <strong>ScriptableObject をまとめてバインド</strong></li>
<li>絞り込み・検索・ボタン操作などを Odin の属性でサクッと実装</li>
<li>「触ってはいけない項目」は <strong>ReadOnly / Foldout / Box などでガード</strong></li>
</ul>
<p>という構成です。</p>
<hr>
<h2>やりたかったこと</h2>
<p>このコンテキストエディターでは、主に次のような体験を目指しました。</p>
<h3>1. 「どこを触ればいいか」が一目で分かる</h3>
<ul>
<li>プランナーが Unity に詳しくなくても、<ul>
<li><strong>左側にカテゴリー</strong></li>
<li><strong>右側に編集する内容</strong></li>
</ul>
</li>
<li>という形で、「エクセルを開く感覚」でパラメータを触れるようにしました。</li>
</ul>
<p>具体的には：</p>
<ul>
<li>セクションごとに <code>Foldout</code> や <code>Title</code> 属性で区切る</li>
<li>「ゲーム内に表示される文言」だけをまとめた枠を用意</li>
<li>管理用の ID や内部フラグは ReadOnly で表示のみ</li>
</ul>
<p>など、Odin の装飾系属性をフル活用しています。</p>
<h3>2. 関連データを横断して編集できる</h3>
<p>たとえば「◯◯イベント」のコンテキストだったら、</p>
<ul>
<li>イベント全体の基本設定</li>
<li>各ステージの難易度テーブル</li>
<li>報酬テーブル</li>
<li>ガイド用のテキスト</li>
</ul>
<p>など、別々の ScriptableObject に分かれている情報を、<strong>1つのウィンドウに並べて編集</strong>できるようにしました。</p>
<p>Odin の <code>InlineEditor</code> や <code>TableList</code> を使うことで、</p>
<ul>
<li>参照先の ScriptableObject を、その場で展開して編集</li>
<li>配列・リストをテーブル形式で編集</li>
</ul>
<p>といった UI を、カスタム EditorWindow 側に貼り付けることができました。</p>
<h3>3. 安全な範囲だけ触れるようにする</h3>
<ul>
<li>プランナーには見えてほしいが、触ってほしくないフィールド</li>
<li>開発途中で変更すると危険なフラグ</li>
</ul>
<p>こういったものは、</p>
<ul>
<li><code>ReadOnly</code> 属性でロック</li>
<li><code>HideIf</code> / <code>ShowIf</code> でそもそも見せない</li>
<li><code>InfoBox</code> で注意書きを出す</li>
</ul>
<p>などの工夫を入れて、<strong>「自由度は残しつつ、壊れにくい UI」にする</strong>ことを意識しました。</p>
<hr>
<h2>実装構成</h2>
<p>技術的な構成は、おおよそこんな感じです。</p>
<h3>1. ベースとなる Window クラス</h3>
<ul>
<li><code>OdinEditorWindow</code> を継承した <code>ContextEditorWindow</code> を用意</li>
<li><code>MenuItem</code> 属性でメニューから開けるようにする</li>
</ul>
<pre><code class="language-csharp">using Sirenix.OdinInspector;
using Sirenix.OdinInspector.Editor;
using UnityEditor;
using UnityEngine;

public class ContextEditorWindow : OdinEditorWindow
{
    [MenuItem(&quot;Tools/Context Editor&quot;)]
    private static void Open()
    {
        GetWindow&lt;ContextEditorWindow&gt;(&quot;Context Editor&quot;);
    }

    // プランナーが触る対象をここに並べる
    [Title(&quot;イベント基本設定&quot;)]
    [InlineEditor(Expanded = true)]
    public EventConfig eventConfig;

    [Title(&quot;ステージ設定&quot;)]
    [TableList]
    public StageConfig[] stages;

    [Title(&quot;報酬設定&quot;)]
    [TableList]
    public RewardConfig[] rewards;

    // 必要なら、検索・フィルタ用のフィールドもここに置く
}
</code></pre>
<p>ウィンドウを開くだけで</p>
<ul>
<li>指定したScriptableObjectの中身が<strong>同じ画面</strong>に展開される</li>
<li>その場で値を編集、ほぞんが　反映される
という状態にできます。</li>
</ul>
<h3>2. ScriptableObject側の設計</h3>
<p>もともとのデータ構造をScriptableObject化しておけば</p>
<ul>
<li>プロジェクト全体では通常通りScriptableObjectとして利用</li>
<li>編集時だけコンテキストエディターのウィンドウからアクセス
という二重の使い方ができます。</li>
</ul>
<p>例えば :</p>
<pre><code class="language-csharp">[CreateAssetMenu(menuName = &quot;Game/Event&quot;)]
public class EventConfig : ScriptableObject
{
    [LabelText(&quot;イベント名&quot;)]
    public string eventName;
    
    [LabelText(&quot;開催期間&quot;)]
    public string durationText;
    
    [LabelText(&quot;説明文&quot;)]
    public string description;
    
    [LabelText(&quot;有効フラグ&quot;)]
    public bool isEnabled;
}
</code></pre>
<p>これを先ほどのContextEditorWindowのフィールドとして参照しておけば、
ウィンドウ側でInlineEditorしたときに、<strong>Odinのデコレーション込みで表示されます</strong>。</p>
<h3>3. ちょっとしたUX改善</h3>
<p>例：</p>
<ul>
<li>「選択中のステージだけテストシーンを起動する」ボタン</li>
<li>「報酬テーブルをデフォルト値で初期化する」ボタン</li>
<li>「特定 ID のデータを検索してフォーカス」ボタン
Odin の Button 属性を使えば、EditorWindow 内にメソッドをそのままボタンとして出せるので、
ちょっとしたツール感を簡単に足せます</li>
</ul>
<h2>実際に運用してみて</h2>
<p>実際にプランナーに使ってもらって感じたメリットはこんな感じでした。</p>
<ul>
<li>「この仕様を触りたいときは、このウィンドウを開けばいい」という入口が固定された</li>
<li>Unity の Project ウィンドウや Inspector をさまよう時間が減った</li>
<li>パラメータの更新とコミュニケーションのログが取りやすくなった（「この画面のここを変えました」と言いやすい）</li>
<li>誤操作されると困る部分は最初からロックしておけるので、事故が減った</li>
</ul>
<p>一方で、課題としては：</p>
<ul>
<li>コンテキストエディター自体のメンテナンスコストが発生する</li>
<li>データ構造を弄るときは、Editor 側の反映も忘れないようにする必要がある</li>
<li>UI を作り込みすぎると「専用ツール」になりすぎて、柔軟性が落ちる</li>
</ul>
<p>といった点もありました。</p>
<h2>最後に</h2>
<p>Odin を使ったコンテキストエディターは、</p>
<ul>
<li>「プランナーが直接触れる Unity ツール」を作りたいとき</li>
<li>「プロジェクト専用の編集画面」をサクッと用意したいとき</li>
</ul>
<p>にかなり相性がいいと感じました。</p>
<p>Inspector 拡張だけでは足りないけれど、EditorWindow をフルスクラッチするのは大変
というケースでは、Odin の属性と EditorWindow を組み合わせるだけで、
「ちょうどいいライン」のツールが作りやすいです。</p>
<p>今後は、</p>
<ul>
<li>もう少し UI/UX を整理したバージョン</li>
<li>別プロジェクトでも使い回せるような抽象化</li>
</ul>
<p>にもチャレンジしてみたいと思っています。</p>
<p>興味があれば、別の記事で具体的なコードや属性の使い方も掘り下げていくので、また読んでもらえたら嬉しいです。</p>

          </section>
        </article>
      </main>
    </div>

    <script src="../assets/js/layout.js" defer></script>
    <script src="../assets/js/ui.js"></script>
  </body>
</html>