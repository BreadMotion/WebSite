---
title: RClone運用フロー
date: 2025-11-20
category: CloudStrage
description: プロジェクトでrcloneとシェルスクリプトを活用し、大規模アセットの効率的な管理とCI/CD連携を実現する方法を解説します。
tags: [tool, cloudstrage, git]
thumbnail: https://images.icon-icons.com/2699/PNG/512/rclone_logo_icon_169806.png
---

こんにちは！パン君です。

前回の記事ではWindows環境におけるrcloneの導入フローとGoogle Driveとの連携について解説しました。  
今回はその続きとして、 **プロジェクトでの大規模アセット管理** という具体的な課題に対し、rcloneとシェルスクリプトを組み合わせた運用術をご紹介します。  

特にGit LFSの運用で直面しがちな容量制限やパフォーマンスの問題を解決し、  
チーム開発におけるアセット管理の効率化とCI/CD連携をスムーズに行うための実践的なアプローチを探ります。  

## この記事のゴール

- プロジェクトの大規模アセット（モデル、テクスチャ、サウンドなど）をrcloneで効率的に管理する。
- 以下のカスタムシェルスクリプトを活用し、Gitとrcloneの連携を自動化する。
    - `Aup.sh`: アセットのアップロード
    - `Adown.sh`: アセットのダウンロード
    - `Alock.sh`: アセットのロック
    - `Aunlock.sh`: アセットのアンロック
- CI/CDパイプラインにおけるアセットの自動同期・ビルド連携のイメージを掴む。

## 大規模アセット管理の課題とrcloneの優位性

ゲーム開発では3Dモデル、高解像度テクスチャ、長尺サウンドファイルなど、GB単位の大規模アセットが頻繁に登場します。  
これらをGitで直接管理するとリポジトリが肥大化し、クローンやフェッチに時間がかかったりGit LFSの容量制限に引っかかったりといった問題が発生しがちです。  

rcloneを外部ストレージ（Google Driveなどと連携させることでこれらの大容量アセットをGitリポジトリから切り離し効率的に管理することが可能になります。  
Gitではアセットへの参照のみを管理し実際のデータはrclone経由で外部ストレージに保存することでリポジトリの軽量化と高速化を実現します。  

## UEでのRClone運用戦略

UEのルートディレクトリに`Tool`を用意して4つのシェルスクリプトを用意します。(batchファイルに置き換えてコマンド調整しても大丈夫なはず) 
- `Aup.sh`
- `Adown.sh`
- `Alock.sh`
- `Aunlock.sh` 

これらのスクリプトは`Assets`ディレクトリ以下の大容量ファイルになりうるプリフィックスを対象としてrcloneコマンドをラップしアセットの同期とロックを自動化します。  
(拡張子が.uasset以外の物で対象にしたい場合、判定を追加する事)

### 1. `Aup.sh`：アセットのアップロード

`Aup.sh`は、ローカルのプロジェクトのアセットをGoogle Drive（または設定されたリモートストレージにアップロードするために使用します。  
これはアセットの編集が完了し、共有準備ができた際に実行するイメージです。

**使用例:**
```sh
# Unityプロジェクトのルートディレクトリで実行
sh ./Tool/Aup.sh
```

**内部処理の概要:**
1.  `Content` ディレクトリ以下のファイルを走査。
2.  各ファイルをrcloneコマンドでリモートストレージにアップロード。
3.  Gitリポジトリには、アップロードされたアセットのプレースホルダーファイル（またはパス情報のみ）をコミット。

### 2. `Adown.sh`：アセットのダウンロード

`Adown.sh` はリモートストレージ上のアセットをローカルのプロジェクトにダウンロードするために使用します。  
チームメンバーがプロジェクトをクローンしたり、最新のアセットに更新したい場合に実行します。

**使用例:**
```sh
# プロジェクトのルートディレクトリで実行
sh ./Tool/Adown.sh
```

**内部処理の概要:**
1.  Gitリポジトリ内のアセット参照情報を取得。
2.  rcloneコマンドで、対応するアセットファイルをリモートストレージから `Content` ディレクトリにダウンロード。
3.  ダウンロードされたアセットがエディタで認識されるように調整（必要であれば）。

### 3. `Alock.sh`：アセットのロック

大規模アセットの同時編集によるコンフリクトを防ぐためにロック機構は非常に重要です。  
`Alock.sh` は、特定のアセットをロックし、他のメンバーが同時に編集できないようにします。  

**使用例:**
```sh
# UEプロジェクトのルートディレクトリで実行
sh ./Tool/Alock.sh Content/Model/SK_ModelX.uasset
```

**内部処理の概要:**
1.  指定されたアセットのロック情報をリモートストレージまたは専用のロック管理システムに登録。
2.  Gitリポジトリにもロック状態を反映する。
3.  ロックが成功したことを通知。既にロックされている場合はエラーメッセージを表示。

### 4. `Aunlock.sh`：アセットのアンロック

アセットの編集が完了し`Aup.sh` でアップロードが済んだら`Aunlock.sh` を使ってロックを解除します。

**使用例:**
```sh
# プロジェクトのルートディレクトリで実行
sh ./Tool/Aunlock.sh Content/Model/SK_ModelX.uasset
```

**内部処理の概要:**
1.  指定されたアセットのロック情報をリモートストレージまたはロック管理システムから解除。
2.  Gitリポジトリのロック状態を更新。
3.  アンロックが成功したことを通知。ロックされていない場合や他のユーザーがロックしている場合はエラーメッセージを表示。

## CI/CDパイプラインとの連携

これらのスクリプトはCI/CDパイプラインにも容易に組み込むことができます。

**ビルドサーバーでの自動同期例:**
1.  CIがトリガーされた際、まず `git clone` でリポジトリをフェッチ。
2.  次に `./Tool/Adown.sh` を実行し、必要なアセットを自動ダウンロード。
3.  コマンドラインビルドを実行。

これによりビルドサーバーは常に最新のコードとアセットでビルドを実行でき、手動でのアセット同期の手間を省くことができます。

## `MMD_rclone.png` を参照したイメージ（仮想的な図）

前回のRClone導入フローチャート (`MMD_rclone.png`) は、RClone自体の設定フローでしたが  
今回の運用術におけるアセットの流れは以下のようなイメージになります。  

最終版のフローチャートは[こちら](https://breadmotion.github.io/WebSite/content/other/Rclone2.html)です。  
![RClone導入フローチャート](https://breadmotion.github.io/WebSite/assets/img/MMD_rclone2.png)

## ロック・アンロックの重要性 (`Alock.sh` / `Aunlock.sh`)

複数人で同時に編集する際、意図しない上書きやコンフリクトは避けたい問題です。  
Git LFS のファイルロック機能と同様に`rclone`を利用したアセット管理においてもこのロック機構は非常に重要になります。`Alock.sh`と`Aunlock.sh`は、そのためのカスタムシェルスクリプトです。  

### `Alock.sh`：アセットのロック

`Alock.sh` は指定したアセットファイルをリモートストレージ上で「ロック済み」としてマークします。  
これにより他の開発者が同じファイルを同時に編集するのを防ぎ、コンフリクト発生のリスクを大幅に軽減します。  

**主な機能:**

- 指定されたアセットのパスを受け取る。
- rclone のロック機能（または外部のロック管理システム）を利用し、リモートストレージ上のファイルにロックをかける。
- ロックが成功した場合その旨を通知。
- 既に他のユーザーによってロックされている場合はその情報を表示し、ロックを拒否する。

**運用イメージ:**  
開発者が特定のアセットの編集を始める前に `Alock.sh Content/Model/SK_ModelA.uasset` を実行します。  
ロックが成功すれば安心して作業を進めることができます。  

### `Aunlock.sh`：アセットのアンロック

アセットの編集が完了し`Aup.sh`でリモートストレージへのアップロードが済んだら`Aunlock.sh`を使ってロックを解除します。  
これにより他の開発者がそのアセットをロックし、編集できるようになります。  

**主な機能:**

- 指定されたアセットのパスを受け取る。
- リモートストレージ上のファイルのロックを解除する。
- ロック解除が成功した場合その旨を通知。
- ロックされていないファイルや自分以外のユーザーがロックしているファイルを解除しようとした場合はエラーを通知する。

**運用イメージ:**  
アセットの編集とアップロードが終わったら`Aunlock.sh Content/Model/SK_ModelA.uasset`を実行してロックを解除します。  
これにより他のチームメンバーがそのアセットの最新版を取得し、必要であればロックして編集を開始できます。

### ロック機構のメリット

- **コンフリクトの防止**: 大容量アセットの複雑なマージ作業を回避できる。
- **明確な担当範囲**: 誰がどのアセットを編集しているか一目で分かり、無駄な作業重複を防ぐ。
- **チーム開発の効率化**: スムーズなアセット連携により開発全体の生産性が向上する。

これらのスクリプトとフローを適切に運用することで、Gitとrcloneを組み合わせたプロジェクトのアセット管理はより堅牢で効率的なものとなるでしょう。

## まとめ

プロジェクトにおけるアセット管理はチーム開発の効率を大きく左右する重要な課題です。  
rcloneとカスタムシェルスクリプト `Aup.sh`, `Adown.sh`, `Alock.sh`, `Aunlock.sh` を組み合わせることで、Gitリポジトリを軽量に保ちつつ大容量アセットを外部ストレージで効率的に管理し、さらにCI/CDパイプラインとの連携もスムーズに行うことが可能になります。  

この運用術を導入することで開発者はアセットの容量やGit LFSの制限に煩わされることなくコンテンツ制作と開発に集中できるようになるでしょう。
